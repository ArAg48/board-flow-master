-- Create trigger to auto-sync scan_sessions from board_data activity
CREATE OR REPLACE FUNCTION public.sync_scan_sessions_from_boards()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_session_id uuid;
  v_session_start timestamp with time zone;
  v_session_end timestamp with time zone;
  v_board_counts record;
BEGIN
  -- Skip if no technician or PTL order
  IF COALESCE(NEW.technician_id, OLD.technician_id) IS NULL OR 
     COALESCE(NEW.ptl_order_id, OLD.ptl_order_id) IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;

  -- Get the PTL order and technician from the triggering record
  DECLARE
    v_ptl_order_id uuid := COALESCE(NEW.ptl_order_id, OLD.ptl_order_id);
    v_technician_id uuid := COALESCE(NEW.technician_id, OLD.technician_id);
  BEGIN
    
    -- Find or create a session for this technician/PTL order combination
    -- Look for an existing session from the same day
    SELECT id INTO v_session_id
    FROM public.scan_sessions ss
    WHERE ss.technician_id = v_technician_id
      AND ss.ptl_order_id = v_ptl_order_id
      AND DATE(ss.start_time) = DATE(COALESCE(NEW.test_date, OLD.test_date, now()))
    ORDER BY ss.created_at DESC
    LIMIT 1;

    -- If no session exists, create one
    IF v_session_id IS NULL THEN
      v_session_id := gen_random_uuid();
      
      -- Use the earliest board scan time as session start
      SELECT MIN(bd.test_date), MAX(bd.test_date) 
      INTO v_session_start, v_session_end
      FROM public.board_data bd
      WHERE bd.technician_id = v_technician_id 
        AND bd.ptl_order_id = v_ptl_order_id
        AND bd.test_date IS NOT NULL;
      
      -- Fallback to current time if no test dates
      v_session_start := COALESCE(v_session_start, now());
      v_session_end := CASE WHEN v_session_end = v_session_start THEN NULL ELSE v_session_end END;

      INSERT INTO public.scan_sessions (
        id,
        technician_id,
        ptl_order_id,
        start_time,
        end_time,
        status,
        is_active,
        session_data,
        tester_config,
        duration_minutes,
        actual_duration_minutes
      ) VALUES (
        v_session_id,
        v_technician_id,
        v_ptl_order_id,
        v_session_start,
        v_session_end,
        CASE WHEN v_session_end IS NULL THEN 'active'::session_status ELSE 'completed'::session_status END,
        CASE WHEN v_session_end IS NULL THEN true ELSE false END,
        jsonb_build_object(
          'id', v_session_id,
          'startTime', v_session_start,
          'endTime', v_session_end,
          'status', CASE WHEN v_session_end IS NULL THEN 'active' ELSE 'completed' END,
          'autoGenerated', true
        ),
        jsonb_build_object('type', 1, 'scanBoxes', 1),
        CASE WHEN v_session_end IS NOT NULL THEN 
          GREATEST(1, FLOOR(EXTRACT(EPOCH FROM (v_session_end - v_session_start)) / 60)::int)
        ELSE NULL END,
        CASE WHEN v_session_end IS NOT NULL THEN 
          GREATEST(1, FLOOR(EXTRACT(EPOCH FROM (v_session_end - v_session_start)) / 60)::int)
        ELSE NULL END
      );
    END IF;

    -- Now update the session with current board counts
    SELECT 
      COUNT(*) as total_scanned,
      COUNT(*) FILTER (WHERE test_status = 'pass') as pass_count,
      COUNT(*) FILTER (WHERE test_status = 'fail') as fail_count
    INTO v_board_counts
    FROM public.board_data bd
    WHERE bd.technician_id = v_technician_id 
      AND bd.ptl_order_id = v_ptl_order_id;

    -- Update session counts and timing
    UPDATE public.scan_sessions 
    SET 
      total_scanned = v_board_counts.total_scanned,
      pass_count = v_board_counts.pass_count,
      fail_count = v_board_counts.fail_count,
      session_scanned_count = v_board_counts.total_scanned,
      session_pass_count = v_board_counts.pass_count,
      session_fail_count = v_board_counts.fail_count,
      updated_at = now()
    WHERE id = v_session_id;

  END;

  RETURN COALESCE(NEW, OLD);
END;
$$;

-- Create trigger on board_data
DROP TRIGGER IF EXISTS trigger_sync_scan_sessions ON public.board_data;
CREATE TRIGGER trigger_sync_scan_sessions
  AFTER INSERT OR UPDATE OR DELETE ON public.board_data
  FOR EACH ROW
  EXECUTE FUNCTION public.sync_scan_sessions_from_boards();

-- Backfill existing board_data to create scan_sessions
DO $$
DECLARE
  board_record record;
BEGIN
  -- Process each technician/PTL order combination that has board data but no sessions
  FOR board_record IN
    SELECT DISTINCT 
      bd.technician_id,
      bd.ptl_order_id,
      MIN(bd.test_date) as earliest_scan,
      MAX(bd.test_date) as latest_scan,
      COUNT(*) as total_scanned,
      COUNT(*) FILTER (WHERE bd.test_status = 'pass') as pass_count,
      COUNT(*) FILTER (WHERE bd.test_status = 'fail') as fail_count
    FROM public.board_data bd
    WHERE bd.technician_id IS NOT NULL 
      AND bd.ptl_order_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM public.scan_sessions ss 
        WHERE ss.technician_id = bd.technician_id 
          AND ss.ptl_order_id = bd.ptl_order_id
      )
    GROUP BY bd.technician_id, bd.ptl_order_id
  LOOP
    -- Create session for this combination
    INSERT INTO public.scan_sessions (
      id,
      technician_id,
      ptl_order_id,
      start_time,
      end_time,
      status,
      is_active,
      total_scanned,
      pass_count,
      fail_count,
      session_scanned_count,
      session_pass_count,
      session_fail_count,
      duration_minutes,
      actual_duration_minutes,
      session_data,
      tester_config
    ) VALUES (
      gen_random_uuid(),
      board_record.technician_id,
      board_record.ptl_order_id,
      COALESCE(board_record.earliest_scan, now() - interval '1 hour'),
      CASE 
        WHEN board_record.latest_scan != board_record.earliest_scan 
        THEN board_record.latest_scan 
        ELSE NULL 
      END,
      'completed'::session_status,
      false,
      board_record.total_scanned,
      board_record.pass_count,
      board_record.fail_count,
      board_record.total_scanned,
      board_record.pass_count,
      board_record.fail_count,
      CASE 
        WHEN board_record.latest_scan IS NOT NULL AND board_record.earliest_scan IS NOT NULL
        THEN GREATEST(1, FLOOR(EXTRACT(EPOCH FROM (board_record.latest_scan - board_record.earliest_scan)) / 60)::int)
        ELSE 30 -- Default 30 minutes for single-time sessions
      END,
      CASE 
        WHEN board_record.latest_scan IS NOT NULL AND board_record.earliest_scan IS NOT NULL
        THEN GREATEST(1, FLOOR(EXTRACT(EPOCH FROM (board_record.latest_scan - board_record.earliest_scan)) / 60)::int)
        ELSE 30
      END,
      jsonb_build_object(
        'backfilled', true,
        'startTime', COALESCE(board_record.earliest_scan, now() - interval '1 hour'),
        'endTime', board_record.latest_scan,
        'status', 'completed'
      ),
      jsonb_build_object('type', 1, 'scanBoxes', 1)
    );
  END LOOP;
END;
$$;